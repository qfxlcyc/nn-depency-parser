import json

class Node:

    def __init__(self, val=-1):
        self.val = val
        self.left_children = []
        self.right_children = []

    def add_child(self, child, left=False):
        # the later a child is added, the more left/right-most the child is.
        if left:
            self.left_children.append(child)
        else:
            self.right_children.append(child)

    def nth_child(self, n, left=False):
        if left:
            return self.left_children[-n] if n <= len(self.left_children) else Node()
        else:
            return self.right_children[-n] if n <= len(self.right_children) else Node()

    def serialize(self):
        json_dict = {
            "val": self.val
        }
        if self.left_children:
            json_dict["left_children"] = [ch.serialize() for ch in self.left_children]
        if self.right_children:
            json_dict["right_children"] = [ch.serialize() for ch in self.right_children]
        return json_dict


class Parser:
    SHIFT, LEFT, RIGHT = range(3)
    # OOV, NULL = range(2)
    NULL = 0

    def __init__(self, skip2shifts=True):
        # auto add first two items (if any) to stack to skip the first two shift actions
        self.skip2shifts = skip2shifts

    def fit(self, buffer_size):
        if self.skip2shifts:
            self.stack = [Node()] + [Node(i) for i in xrange(min(2, buffer_size))]
            self.buffer = [Node(i) for i in reversed(xrange(2, buffer_size))]
        else:
            self.stack = [Node()]
            self.buffer = [Node(i) for i in reversed(xrange(buffer_size))]
        self.arc_set = []

    def step(self, label):
        """execuate action and update stack, buffer and arc-set"""
        action = self._get_direction_from_label(label)
        if action == Parser.SHIFT: # shift
            self.stack.append(self.buffer.pop())
        elif action == Parser.LEFT:   # left-arc
            end = self.stack.pop(-2)
            start = self.stack[-1]
            self.arc_set.append((start.val, end.val))
            start.add_child(end, left=True)

        else: #right-arc
            end = self.stack.pop()
            start = self.stack[-1]
            self.arc_set.append((start.val, end.val))
            start.add_child(end, left=False)

    def end(self):
        return len(self.stack) == 1 and len(self.buffer) == 0

    def _get_direction_from_label(self, label):
        if label == 0: return Parser.SHIFT
        elif label % 2: return Parser.LEFT
        else: return Parser.RIGHT

    def create_features(self, sentence, pos, arc_labels):
        """create model inputs from parser's current configuration"""

        def n_top_nodes(l, n=3):
            return l[:n] + [Node() for _ in xrange(n-len(l))]

        def get_value_by_node_index(values, nodes, default=Parser.NULL):
            """return values indexed by indexes stored in nodes, with default value filled in if the index is out of range"""
            return [values[n.val] if 0 <= n.val < len(values) else default for n in nodes]

        feature_nodes = []
        stack_top3_nodes = n_top_nodes(list(reversed(self.stack)), 3)
        buffer_top3_nodes = n_top_nodes(list(reversed(self.buffer)), 3)
        # print "stack top 3: %s" % (','.join(str(n.val) for n in stack_top3_nodes))
        # print "buffer top 3: %s" % (','.join(str(n.val) for n in buffer_top3_nodes))
        for node in stack_top3_nodes[:2]:
            if not node: 
                feature_nodes += [Node() for _ in xrange(6)]
                continue
            lc1, lc2, rc1, rc2 = node.nth_child(1, left=True), node.nth_child(2, left=True), node.nth_child(1), node.nth_child(2)
            lc1_lc1, rc1_rc1 = lc1.nth_child(1, left=True), rc1.nth_child(1)
            feature_nodes += [lc1, lc2, rc1, rc2, lc1_lc1, rc1_rc1]
            # print "feature nodes generated by node %s: %s" % (str(node.val), ','.join(str(n.val) for n in [lc1, lc2, rc1, rc2, lc1_lc1, rc1_rc1]))

        # 12 arc features
        arc_feat = get_value_by_node_index(arc_labels, feature_nodes)

        feature_nodes += stack_top3_nodes + buffer_top3_nodes

        # 18 pos and word feature_nodes
        pos_feat = get_value_by_node_index(pos, feature_nodes)
        sentence_feat = get_value_by_node_index(sentence, feature_nodes)
        # print [n.val for n in feature_nodes]
        
        return sentence_feat + pos_feat + arc_feat
        # return sentence_feat


    def _generate_directions_from_arcs(self, arcs):
        def is_projective(e, s, prev_e, prev_s):
            return e >= prev_s or s <= prev_s

        stacks = []
        directions = []
        for e, s in arcs:
            directions.append(Parser.SHIFT)
            if not stacks: 
                stacks.append([e, s])
                continue
            while stacks:
                prev_e, prev_s = stacks[-1]
                if not is_projective(e, s, prev_e, prev_s):
                    print "Record is not projective, skip"
                    # print [(e, s), (prev_e, prev_s)]
                    print arcs
                    return []
                if e >= prev_s > 0:
                    directions.append(Parser.LEFT)
                    stacks.pop()
                else:
                    break
            if e > s > 0:
                directions.append(Parser.RIGHT)
            else:
                stacks.append([e, s])


        if len(stacks) != 1:
            print arcs
            raise Exception("Error in creating directions for record. Should have a remaining right-arc to root")
        directions.append(Parser.RIGHT)
        return directions


    def create_labels(self, arcs, arc_labels, label2id_dict):
        labels = []
        i = 0
        directions = self._generate_directions_from_arcs(arcs)
        for d in directions:
            if d == Parser.SHIFT: labels.append(label2id_dict['SHIFT'])
            else: 
                # prefix = 'LEFT_' if d == Parser.LEFT else 'RIGHT_'
                # labels.append(label2id_dict[prefix + arc_labels[i]])
                l = 'LEFT' if d == Parser.LEFT else 'RIGHT'
                labels.append(label2id_dict[l])
                i += 1
        return labels

    def serialize(self):
        return {
            "stack": [n.serialize() for n in self.stack],
            "buffer": [n.serialize() for n in self.buffer],
            "arc_set": self.arc_set
            }

def main():
    parser = Parser()
    parser.fit(8)
    labels = [0, 0, 7, 0, 0, 0, 9, 0, 0, 13, 7, 3, 1, 0, 20, 14]
    for l in labels[2:-1]:
        parser.step(l)
        print parser.serialize()

if __name__ == '__main__':
    main()